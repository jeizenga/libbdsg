#include <bdsg/graph_proxy.hpp>
#include <bdsg/internal/base_packed_graph.hpp>
#include <bdsg/internal/mapped_structs.hpp>
#include <sstream> // __str__

#include <pybind11/pybind11.h>
#include <functional>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <pybind11/functional.h>
#include <fstream>
#include <bdsg/internal/binder_hook_compile.hpp>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>);
#endif

void bind_bdsg_graph_proxy_7(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // bdsg::GraphProxy file:bdsg/graph_proxy.hpp line:599
		pybind11::class_<bdsg::GraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>, std::shared_ptr<bdsg::GraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>>, bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>, bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>> cl(M("bdsg"), "GraphProxy_bdsg_BasePackedGraph_bdsg_MappedBackend_t", "");
		cl.def("assign", (struct bdsg::GraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::GraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::GraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::GraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::GraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::GraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::GraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("create_handle", (struct handlegraph::handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_handle, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_handle(const std::string &) --> struct handlegraph::handle_t", pybind11::arg("sequence"));
		cl.def("create_handle", (struct handlegraph::handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &, const long long &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_handle, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_handle(const std::string &, const long long &) --> struct handlegraph::handle_t", pybind11::arg("sequence"), pybind11::arg("id"));
		cl.def("create_edge", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_edge, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_edge(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) --> void", pybind11::arg("left"), pybind11::arg("right"));
		cl.def("apply_orientation", (struct handlegraph::handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::apply_orientation, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::apply_orientation(const struct handlegraph::handle_t &) --> struct handlegraph::handle_t", pybind11::arg("handle"));
		cl.def("divide_handle", (class std::vector<handlegraph::handle_t> (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, const class std::vector<unsigned long> &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::divide_handle, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::divide_handle(const struct handlegraph::handle_t &, const class std::vector<unsigned long> &) --> class std::vector<handlegraph::handle_t>", pybind11::arg("handle"), pybind11::arg("offsets"));
		cl.def("optimize", [](bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>> &o) -> void { return o.optimize(); }, "");
		cl.def("optimize", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(bool)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::optimize, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::optimize(bool) --> void", pybind11::arg("allow_id_reassignment"));
		cl.def("apply_ordering", [](bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>> &o, const class std::vector<handlegraph::handle_t> & a0) -> void { return o.apply_ordering(a0); }, "", pybind11::arg("order"));
		cl.def("apply_ordering", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const class std::vector<handlegraph::handle_t> &, bool)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::apply_ordering, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::apply_ordering(const class std::vector<handlegraph::handle_t> &, bool) --> void", pybind11::arg("order"), pybind11::arg("compact_ids"));
		cl.def("set_id_increment", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const long long &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::set_id_increment, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::set_id_increment(const long long &) --> void", pybind11::arg("min_id"));
		cl.def("increment_node_ids", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(long long)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::increment_node_ids, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::increment_node_ids(long long) --> void", pybind11::arg("increment"));
		cl.def("increment_node_ids", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(long)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::increment_node_ids, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::increment_node_ids(long) --> void", pybind11::arg("increment"));
		cl.def("reassign_node_ids", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const class std::function<long long (const long long &)> &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::reassign_node_ids, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::reassign_node_ids(const class std::function<long long (const long long &)> &) --> void", pybind11::arg("get_new_id"));
		cl.def("destroy_path", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::destroy_path, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::destroy_path(const struct handlegraph::path_handle_t &) --> void", pybind11::arg("path"));
		cl.def("create_path_handle", [](bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>> &o, const std::string & a0) -> handlegraph::path_handle_t { return o.create_path_handle(a0); }, "", pybind11::arg("name"));
		cl.def("create_path_handle", (struct handlegraph::path_handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &, bool)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_path_handle, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::create_path_handle(const std::string &, bool) --> struct handlegraph::path_handle_t", pybind11::arg("name"), pybind11::arg("is_circular"));
		cl.def("append_step", (struct handlegraph::step_handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &, const struct handlegraph::handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::append_step, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::append_step(const struct handlegraph::path_handle_t &, const struct handlegraph::handle_t &) --> struct handlegraph::step_handle_t", pybind11::arg("path"), pybind11::arg("to_append"));
		cl.def("prepend_step", (struct handlegraph::step_handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &, const struct handlegraph::handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::prepend_step, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::prepend_step(const struct handlegraph::path_handle_t &, const struct handlegraph::handle_t &) --> struct handlegraph::step_handle_t", pybind11::arg("path"), pybind11::arg("to_prepend"));
		cl.def("rewrite_segment", (struct std::pair<struct handlegraph::step_handle_t, struct handlegraph::step_handle_t> (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &, const struct handlegraph::step_handle_t &, const class std::vector<handlegraph::handle_t> &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::rewrite_segment, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::rewrite_segment(const struct handlegraph::step_handle_t &, const struct handlegraph::step_handle_t &, const class std::vector<handlegraph::handle_t> &) --> struct std::pair<struct handlegraph::step_handle_t, struct handlegraph::step_handle_t>", pybind11::arg("segment_begin"), pybind11::arg("segment_end"), pybind11::arg("new_segment"));
		cl.def("set_circularity", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &, bool)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::set_circularity, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::set_circularity(const struct handlegraph::path_handle_t &, bool) --> void", pybind11::arg("path"), pybind11::arg("circular"));
		cl.def("destroy_handle", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::destroy_handle, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::destroy_handle(const struct handlegraph::handle_t &) --> void", pybind11::arg("handle"));
		cl.def("destroy_edge", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::destroy_edge, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::destroy_edge(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) --> void", pybind11::arg("left"), pybind11::arg("right"));
		cl.def("truncate_handle", (struct handlegraph::handle_t (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, bool, unsigned long)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::truncate_handle, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::truncate_handle(const struct handlegraph::handle_t &, bool, unsigned long) --> struct handlegraph::handle_t", pybind11::arg("handle"), pybind11::arg("trunc_left"), pybind11::arg("offset"));
		cl.def("clear", (void (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)()) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::clear, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::clear() --> void");
		cl.def("assign", (struct bdsg::MutablePathDeletableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::MutablePathDeletableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::MutablePathDeletableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::MutablePathDeletableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::MutablePathDeletableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("get_path_count", (unsigned long (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_count, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_count() const --> unsigned long");
		cl.def("has_path", (bool (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_path, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_path(const std::string &) const --> bool", pybind11::arg("path_name"));
		cl.def("get_path_handle", (struct handlegraph::path_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_handle, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_handle(const std::string &) const --> struct handlegraph::path_handle_t", pybind11::arg("path_name"));
		cl.def("get_path_name", (std::string (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_name, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_name(const struct handlegraph::path_handle_t &) const --> std::string", pybind11::arg("path_handle"));
		cl.def("get_is_circular", (bool (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_is_circular, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_is_circular(const struct handlegraph::path_handle_t &) const --> bool", pybind11::arg("path_handle"));
		cl.def("get_step_count", (unsigned long (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_step_count, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_step_count(const struct handlegraph::path_handle_t &) const --> unsigned long", pybind11::arg("path_handle"));
		cl.def("get_step_count", (unsigned long (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_step_count, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_step_count(const struct handlegraph::handle_t &) const --> unsigned long", pybind11::arg("handle"));
		cl.def("get_handle_of_step", (struct handlegraph::handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_handle_of_step, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_handle_of_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::handle_t", pybind11::arg("step_handle"));
		cl.def("get_path_handle_of_step", (struct handlegraph::path_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_handle_of_step, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_path_handle_of_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::path_handle_t", pybind11::arg("step_handle"));
		cl.def("path_begin", (struct handlegraph::step_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_begin, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_begin(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("path_end", (struct handlegraph::step_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_end, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_end(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("path_back", (struct handlegraph::step_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_back, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_back(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("path_front_end", (struct handlegraph::step_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_front_end, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::path_front_end(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("has_next_step", (bool (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_next_step, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_next_step(const struct handlegraph::step_handle_t &) const --> bool", pybind11::arg("step_handle"));
		cl.def("has_previous_step", (bool (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_previous_step, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_previous_step(const struct handlegraph::step_handle_t &) const --> bool", pybind11::arg("step_handle"));
		cl.def("get_next_step", (struct handlegraph::step_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_next_step, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_next_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("step_handle"));
		cl.def("get_previous_step", (struct handlegraph::step_handle_t (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::step_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_previous_step, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_previous_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("step_handle"));
		cl.def("steps_of_handle", [](bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>> const &o, const struct handlegraph::handle_t & a0) -> std::vector<handlegraph::step_handle_t> { return o.steps_of_handle(a0); }, "", pybind11::arg("handle"));
		cl.def("steps_of_handle", (class std::vector<handlegraph::step_handle_t> (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, bool) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::steps_of_handle, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::steps_of_handle(const struct handlegraph::handle_t &, bool) const --> class std::vector<handlegraph::step_handle_t>", pybind11::arg("handle"), pybind11::arg("match_orientation"));
		cl.def("is_empty", (bool (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::path_handle_t &) const) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::is_empty, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::is_empty(const struct handlegraph::path_handle_t &) const --> bool", pybind11::arg("path_handle"));
		cl.def("assign", (struct bdsg::PathHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::PathHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::PathHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::PathHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::PathHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("has_node", (bool (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(long long) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_node, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_node(long long) const --> bool", pybind11::arg("node_id"));
		cl.def("get_handle", [](bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>> const &o, const long long & a0) -> handlegraph::handle_t { return o.get_handle(a0); }, "", pybind11::arg("node_id"));
		cl.def("get_handle", (struct handlegraph::handle_t (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const long long &, bool) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_handle, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_handle(const long long &, bool) const --> struct handlegraph::handle_t", pybind11::arg("node_id"), pybind11::arg("is_reverse"));
		cl.def("get_id", (long long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_id, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_id(const struct handlegraph::handle_t &) const --> long long", pybind11::arg("handle"));
		cl.def("get_is_reverse", (bool (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_is_reverse, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_is_reverse(const struct handlegraph::handle_t &) const --> bool", pybind11::arg("handle"));
		cl.def("flip", (struct handlegraph::handle_t (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::flip, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::flip(const struct handlegraph::handle_t &) const --> struct handlegraph::handle_t", pybind11::arg("handle"));
		cl.def("get_length", (unsigned long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_length, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_length(const struct handlegraph::handle_t &) const --> unsigned long", pybind11::arg("handle"));
		cl.def("get_sequence", (std::string (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_sequence, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_sequence(const struct handlegraph::handle_t &) const --> std::string", pybind11::arg("handle"));
		cl.def("get_node_count", (unsigned long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_node_count, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_node_count() const --> unsigned long");
		cl.def("min_node_id", (long long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::min_node_id, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::min_node_id() const --> long long");
		cl.def("max_node_id", (long long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::max_node_id, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::max_node_id() const --> long long");
		cl.def("get_degree", (unsigned long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, bool) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_degree, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_degree(const struct handlegraph::handle_t &, bool) const --> unsigned long", pybind11::arg("handle"), pybind11::arg("go_left"));
		cl.def("has_edge", (bool (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_edge, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::has_edge(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) const --> bool", pybind11::arg("left"), pybind11::arg("right"));
		cl.def("get_edge_count", (unsigned long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_edge_count, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_edge_count() const --> unsigned long");
		cl.def("get_total_length", (unsigned long (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_total_length, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_total_length() const --> unsigned long");
		cl.def("get_base", (char (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, unsigned long) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_base, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_base(const struct handlegraph::handle_t &, unsigned long) const --> char", pybind11::arg("handle"), pybind11::arg("index"));
		cl.def("get_subsequence", (std::string (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct handlegraph::handle_t &, unsigned long, unsigned long) const) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_subsequence, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_subsequence(const struct handlegraph::handle_t &, unsigned long, unsigned long) const --> std::string", pybind11::arg("handle"), pybind11::arg("index"), pybind11::arg("size"));
		cl.def("assign", (struct bdsg::HandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::HandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::HandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::HandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::HandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("assign", (struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::AbstractGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::AbstractGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::AbstractGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("follow_edges", (bool (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &, bool, const class std::function<bool (const struct handlegraph::handle_t &)> &) const) &handlegraph::HandleGraph::follow_edges<std::function<bool (const handlegraph::handle_t &)>>, "C++: handlegraph::HandleGraph::follow_edges(const struct handlegraph::handle_t &, bool, const class std::function<bool (const struct handlegraph::handle_t &)> &) const --> bool", pybind11::arg("handle"), pybind11::arg("go_left"), pybind11::arg("iteratee"));
		cl.def("for_each_handle", [](handlegraph::HandleGraph const &o, const class std::function<bool (const struct handlegraph::handle_t &)> & a0) -> bool { return o.for_each_handle(a0); }, "", pybind11::arg("iteratee"));
		cl.def("for_each_handle", (bool (handlegraph::HandleGraph::*)(const class std::function<bool (const struct handlegraph::handle_t &)> &, bool) const) &handlegraph::HandleGraph::for_each_handle<std::function<bool (const handlegraph::handle_t &)>>, "C++: handlegraph::HandleGraph::for_each_handle(const class std::function<bool (const struct handlegraph::handle_t &)> &, bool) const --> bool", pybind11::arg("iteratee"), pybind11::arg("parallel"));
		cl.def("for_each_edge", [](handlegraph::HandleGraph const &o, const class std::function<bool (const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &)> & a0) -> bool { return o.for_each_edge(a0); }, "", pybind11::arg("iteratee"));
		cl.def("for_each_edge", (bool (handlegraph::HandleGraph::*)(const class std::function<bool (const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &)> &, bool) const) &handlegraph::HandleGraph::for_each_edge<std::function<bool (const std::pair<handlegraph::handle_t, handlegraph::handle_t> &)>>, "C++: handlegraph::HandleGraph::for_each_edge(const class std::function<bool (const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &)> &, bool) const --> bool", pybind11::arg("iteratee"), pybind11::arg("parallel"));
		cl.def("has_node", (bool (handlegraph::HandleGraph::*)(long long) const) &handlegraph::HandleGraph::has_node, "Method to check if a node exists by ID\n\nC++: handlegraph::HandleGraph::has_node(long long) const --> bool", pybind11::arg("node_id"));
		cl.def("get_handle", [](handlegraph::HandleGraph const &o, const long long & a0) -> handlegraph::handle_t { return o.get_handle(a0); }, "", pybind11::arg("node_id"));
		cl.def("get_handle", (struct handlegraph::handle_t (handlegraph::HandleGraph::*)(const long long &, bool) const) &handlegraph::HandleGraph::get_handle, "Look up the handle for the node with the given ID in the given orientation\n\nC++: handlegraph::HandleGraph::get_handle(const long long &, bool) const --> struct handlegraph::handle_t", pybind11::arg("node_id"), pybind11::arg("is_reverse"));
		cl.def("get_id", (long long (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::get_id, "Get the ID from a handle\n\nC++: handlegraph::HandleGraph::get_id(const struct handlegraph::handle_t &) const --> long long", pybind11::arg("handle"));
		cl.def("get_is_reverse", (bool (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::get_is_reverse, "Get the orientation of a handle\n\nC++: handlegraph::HandleGraph::get_is_reverse(const struct handlegraph::handle_t &) const --> bool", pybind11::arg("handle"));
		cl.def("flip", (struct handlegraph::handle_t (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::flip, "Invert the orientation of a handle (potentially without getting its ID)\n\nC++: handlegraph::HandleGraph::flip(const struct handlegraph::handle_t &) const --> struct handlegraph::handle_t", pybind11::arg("handle"));
		cl.def("get_length", (unsigned long (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::get_length, "Get the length of a node\n\nC++: handlegraph::HandleGraph::get_length(const struct handlegraph::handle_t &) const --> unsigned long", pybind11::arg("handle"));
		cl.def("get_sequence", (std::string (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::get_sequence, "Get the sequence of a node, presented in the handle's local forward\n orientation.\n\nC++: handlegraph::HandleGraph::get_sequence(const struct handlegraph::handle_t &) const --> std::string", pybind11::arg("handle"));
		cl.def("get_node_count", (unsigned long (handlegraph::HandleGraph::*)() const) &handlegraph::HandleGraph::get_node_count, "Return the number of nodes in the graph\n\nC++: handlegraph::HandleGraph::get_node_count() const --> unsigned long");
		cl.def("min_node_id", (long long (handlegraph::HandleGraph::*)() const) &handlegraph::HandleGraph::min_node_id, "Return the smallest ID in the graph, or some smaller number if the\n smallest ID is unavailable. Return value is unspecified if the graph is empty.\n\nC++: handlegraph::HandleGraph::min_node_id() const --> long long");
		cl.def("max_node_id", (long long (handlegraph::HandleGraph::*)() const) &handlegraph::HandleGraph::max_node_id, "Return the largest ID in the graph, or some larger number if the\n largest ID is unavailable. Return value is unspecified if the graph is empty.\n\nC++: handlegraph::HandleGraph::max_node_id() const --> long long");
		cl.def("get_degree", (unsigned long (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &, bool) const) &handlegraph::HandleGraph::get_degree, "Get the number of edges on the right (go_left = false) or left (go_left\n = true) side of the given handle. The default implementation is O(n) in\n the number of edges returned, but graph implementations that track this\n information more efficiently can override this method.\n\nC++: handlegraph::HandleGraph::get_degree(const struct handlegraph::handle_t &, bool) const --> unsigned long", pybind11::arg("handle"), pybind11::arg("go_left"));
		cl.def("has_edge", (bool (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::has_edge, "Returns true if there is an edge that allows traversal from the left\n handle to the right handle. By default O(n) in the number of edges\n on left, but can be overridden with more efficient implementations.\n\nC++: handlegraph::HandleGraph::has_edge(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) const --> bool", pybind11::arg("left"), pybind11::arg("right"));
		cl.def("has_edge", (bool (handlegraph::HandleGraph::*)(const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &) const) &handlegraph::HandleGraph::has_edge, "Convenient wrapper of has_edge for edge_t argument.\n\nC++: handlegraph::HandleGraph::has_edge(const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &) const --> bool", pybind11::arg("edge"));
		cl.def("get_edge_count", (unsigned long (handlegraph::HandleGraph::*)() const) &handlegraph::HandleGraph::get_edge_count, "Return the total number of edges in the graph. If not overridden,\n counts them all in linear time.\n\nC++: handlegraph::HandleGraph::get_edge_count() const --> unsigned long");
		cl.def("get_total_length", (unsigned long (handlegraph::HandleGraph::*)() const) &handlegraph::HandleGraph::get_total_length, "Return the total length of all nodes in the graph, in bp. If not\n overridden, loops over all nodes in linear time.\n\nC++: handlegraph::HandleGraph::get_total_length() const --> unsigned long");
		cl.def("get_base", (char (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &, unsigned long) const) &handlegraph::HandleGraph::get_base, "Returns one base of a handle's sequence, in the orientation of the\n handle.\n\nC++: handlegraph::HandleGraph::get_base(const struct handlegraph::handle_t &, unsigned long) const --> char", pybind11::arg("handle"), pybind11::arg("index"));
		cl.def("get_subsequence", (std::string (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &, unsigned long, unsigned long) const) &handlegraph::HandleGraph::get_subsequence, "Returns a substring of a handle's sequence, in the orientation of the\n handle. If the indicated substring would extend beyond the end of the\n handle's sequence, the return value is truncated to the sequence's end.\n By default O(n) in the size of the handle's sequence, but can be overriden.\n\nC++: handlegraph::HandleGraph::get_subsequence(const struct handlegraph::handle_t &, unsigned long, unsigned long) const --> std::string", pybind11::arg("handle"), pybind11::arg("index"), pybind11::arg("size"));
		cl.def("forward", (struct handlegraph::handle_t (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::forward, "Get the locally forward version of a handle\n\nC++: handlegraph::HandleGraph::forward(const struct handlegraph::handle_t &) const --> struct handlegraph::handle_t", pybind11::arg("handle"));
		cl.def("edge_handle", (struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> (handlegraph::HandleGraph::*)(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::edge_handle, "A pair of handles can be used as an edge. When so used, the handles have a\n canonical order and orientation.\n\nC++: handlegraph::HandleGraph::edge_handle(const struct handlegraph::handle_t &, const struct handlegraph::handle_t &) const --> struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t>", pybind11::arg("left"), pybind11::arg("right"));
		cl.def("traverse_edge_handle", (struct handlegraph::handle_t (handlegraph::HandleGraph::*)(const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &, const struct handlegraph::handle_t &) const) &handlegraph::HandleGraph::traverse_edge_handle, "Such a pair can be viewed from either inward end handle and produce the\n outward handle you would arrive at.\n\nC++: handlegraph::HandleGraph::traverse_edge_handle(const struct std::pair<struct handlegraph::handle_t, struct handlegraph::handle_t> &, const struct handlegraph::handle_t &) const --> struct handlegraph::handle_t", pybind11::arg("edge"), pybind11::arg("left"));
		cl.def("assign", (class handlegraph::HandleGraph & (handlegraph::HandleGraph::*)(const class handlegraph::HandleGraph &)) &handlegraph::HandleGraph::operator=, "C++: handlegraph::HandleGraph::operator=(const class handlegraph::HandleGraph &) --> class handlegraph::HandleGraph &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("for_each_path_handle", (bool (handlegraph::PathHandleGraph::*)(const class std::function<bool (const struct handlegraph::path_handle_t &)> &) const) &handlegraph::PathHandleGraph::for_each_path_handle<std::function<bool (const handlegraph::path_handle_t &)>>, "/////////////////////////////////////////////////////////////////////////\n\nC++: handlegraph::PathHandleGraph::for_each_path_handle(const class std::function<bool (const struct handlegraph::path_handle_t &)> &) const --> bool", pybind11::arg("iteratee"));
		cl.def("for_each_step_on_handle", (bool (handlegraph::PathHandleGraph::*)(const struct handlegraph::handle_t &, const class std::function<bool (const struct handlegraph::step_handle_t &)> &) const) &handlegraph::PathHandleGraph::for_each_step_on_handle<std::function<bool (const handlegraph::step_handle_t &)>>, "C++: handlegraph::PathHandleGraph::for_each_step_on_handle(const struct handlegraph::handle_t &, const class std::function<bool (const struct handlegraph::step_handle_t &)> &) const --> bool", pybind11::arg("handle"), pybind11::arg("iteratee"));
		cl.def("for_each_step_in_path", (bool (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &, const class std::function<bool (const struct handlegraph::step_handle_t &)> &) const) &handlegraph::PathHandleGraph::for_each_step_in_path<std::function<bool (const handlegraph::step_handle_t &)>>, "C++: handlegraph::PathHandleGraph::for_each_step_in_path(const struct handlegraph::path_handle_t &, const class std::function<bool (const struct handlegraph::step_handle_t &)> &) const --> bool", pybind11::arg("path"), pybind11::arg("iteratee"));
		cl.def("get_path_count", (unsigned long (handlegraph::PathHandleGraph::*)() const) &handlegraph::PathHandleGraph::get_path_count, "Returns the number of paths stored in the graph\n\nC++: handlegraph::PathHandleGraph::get_path_count() const --> unsigned long");
		cl.def("has_path", (bool (handlegraph::PathHandleGraph::*)(const std::string &) const) &handlegraph::PathHandleGraph::has_path, "Determine if a path name exists and is legal to get a path handle for.\n\nC++: handlegraph::PathHandleGraph::has_path(const std::string &) const --> bool", pybind11::arg("path_name"));
		cl.def("get_path_handle", (struct handlegraph::path_handle_t (handlegraph::PathHandleGraph::*)(const std::string &) const) &handlegraph::PathHandleGraph::get_path_handle, "Look up the path handle for the given path name.\n The path with that name must exist.\n\nC++: handlegraph::PathHandleGraph::get_path_handle(const std::string &) const --> struct handlegraph::path_handle_t", pybind11::arg("path_name"));
		cl.def("get_path_name", (std::string (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::get_path_name, "Look up the name of a path from a handle to it\n\nC++: handlegraph::PathHandleGraph::get_path_name(const struct handlegraph::path_handle_t &) const --> std::string", pybind11::arg("path_handle"));
		cl.def("get_is_circular", (bool (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::get_is_circular, "Look up whether a path is circular\n\nC++: handlegraph::PathHandleGraph::get_is_circular(const struct handlegraph::path_handle_t &) const --> bool", pybind11::arg("path_handle"));
		cl.def("get_step_count", (unsigned long (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::get_step_count, "Returns the number of node steps in the path\n\nC++: handlegraph::PathHandleGraph::get_step_count(const struct handlegraph::path_handle_t &) const --> unsigned long", pybind11::arg("path_handle"));
		cl.def("get_step_count", (unsigned long (handlegraph::PathHandleGraph::*)(const struct handlegraph::handle_t &) const) &handlegraph::PathHandleGraph::get_step_count, "Returns the number of node steps on a handle\n\nC++: handlegraph::PathHandleGraph::get_step_count(const struct handlegraph::handle_t &) const --> unsigned long", pybind11::arg("handle"));
		cl.def("get_handle_of_step", (struct handlegraph::handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::step_handle_t &) const) &handlegraph::PathHandleGraph::get_handle_of_step, "Get a node handle (node ID and orientation) from a handle to an step on a path\n\nC++: handlegraph::PathHandleGraph::get_handle_of_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::handle_t", pybind11::arg("step_handle"));
		cl.def("get_path_handle_of_step", (struct handlegraph::path_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::step_handle_t &) const) &handlegraph::PathHandleGraph::get_path_handle_of_step, "Returns a handle to the path that an step is on\n\nC++: handlegraph::PathHandleGraph::get_path_handle_of_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::path_handle_t", pybind11::arg("step_handle"));
		cl.def("path_begin", (struct handlegraph::step_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::path_begin, "Get a handle to the first step, which will be an arbitrary step in a circular path\n that we consider \"first\" based on our construction of the path. If the path is empty,\n then the implementation must return the same value as path_end().\n\nC++: handlegraph::PathHandleGraph::path_begin(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("path_end", (struct handlegraph::step_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::path_end, "Get a handle to a fictitious position past the end of a path. This position is\n returned by get_next_step for the final step in a path in a non-circular path.\n Note: get_next_step will *NEVER* return this value for a circular path.\n\nC++: handlegraph::PathHandleGraph::path_end(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("path_back", (struct handlegraph::step_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::path_back, "Get a handle to the last step, which will be an arbitrary step in a circular path that\n we consider \"last\" based on our construction of the path. If the path is empty\n then the implementation must return the same value as path_front_end().\n\nC++: handlegraph::PathHandleGraph::path_back(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("path_front_end", (struct handlegraph::step_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::path_front_end, "Get a handle to a fictitious position before the beginning of a path. This position is\n return by get_previous_step for the first step in a path in a non-circular path.\n Note: get_previous_step will *NEVER* return this value for a circular path.\n\nC++: handlegraph::PathHandleGraph::path_front_end(const struct handlegraph::path_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("path_handle"));
		cl.def("has_next_step", (bool (handlegraph::PathHandleGraph::*)(const struct handlegraph::step_handle_t &) const) &handlegraph::PathHandleGraph::has_next_step, "Returns true if the step is not the last step in a non-circular path.\n\nC++: handlegraph::PathHandleGraph::has_next_step(const struct handlegraph::step_handle_t &) const --> bool", pybind11::arg("step_handle"));
		cl.def("has_previous_step", (bool (handlegraph::PathHandleGraph::*)(const struct handlegraph::step_handle_t &) const) &handlegraph::PathHandleGraph::has_previous_step, "Returns true if the step is not the first step in a non-circular path.\n\nC++: handlegraph::PathHandleGraph::has_previous_step(const struct handlegraph::step_handle_t &) const --> bool", pybind11::arg("step_handle"));
		cl.def("get_next_step", (struct handlegraph::step_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::step_handle_t &) const) &handlegraph::PathHandleGraph::get_next_step, "Returns a handle to the next step on the path. If the given step is the final step\n of a non-circular path, this method has undefined behavior. In a circular path,\n the \"last\" step will loop around to the \"first\" step.\n\nC++: handlegraph::PathHandleGraph::get_next_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("step_handle"));
		cl.def("get_previous_step", (struct handlegraph::step_handle_t (handlegraph::PathHandleGraph::*)(const struct handlegraph::step_handle_t &) const) &handlegraph::PathHandleGraph::get_previous_step, "Returns a handle to the previous step on the path. If the given step is the first\n step of a non-circular path, this method has undefined behavior. In a circular path,\n it will loop around from the \"first\" step (i.e. the one returned by path_begin) to\n the \"last\" step.\n\nC++: handlegraph::PathHandleGraph::get_previous_step(const struct handlegraph::step_handle_t &) const --> struct handlegraph::step_handle_t", pybind11::arg("step_handle"));
		cl.def("steps_of_handle", [](handlegraph::PathHandleGraph const &o, const struct handlegraph::handle_t & a0) -> std::vector<handlegraph::step_handle_t> { return o.steps_of_handle(a0); }, "", pybind11::arg("handle"));
		cl.def("steps_of_handle", (class std::vector<handlegraph::step_handle_t> (handlegraph::PathHandleGraph::*)(const struct handlegraph::handle_t &, bool) const) &handlegraph::PathHandleGraph::steps_of_handle, "Returns a vector of all steps of a node on paths. Optionally restricts to\n steps that match the handle in orientation.\n\nC++: handlegraph::PathHandleGraph::steps_of_handle(const struct handlegraph::handle_t &, bool) const --> class std::vector<handlegraph::step_handle_t>", pybind11::arg("handle"), pybind11::arg("match_orientation"));
		cl.def("is_empty", (bool (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::is_empty, "Returns true if the given path is empty, and false otherwise\n\nC++: handlegraph::PathHandleGraph::is_empty(const struct handlegraph::path_handle_t &) const --> bool", pybind11::arg("path_handle"));
		cl.def("scan_path", (class handlegraph::PathForEachSocket (handlegraph::PathHandleGraph::*)(const struct handlegraph::path_handle_t &) const) &handlegraph::PathHandleGraph::scan_path, "Returns a class with an STL-style iterator interface that can be used directly\n in a for each loop like:\n for (handle_t handle : graph->scan_path(path)) { }\n\nC++: handlegraph::PathHandleGraph::scan_path(const struct handlegraph::path_handle_t &) const --> class handlegraph::PathForEachSocket", pybind11::arg("path"));
		cl.def("assign", (class handlegraph::PathHandleGraph & (handlegraph::PathHandleGraph::*)(const class handlegraph::PathHandleGraph &)) &handlegraph::PathHandleGraph::operator=, "C++: handlegraph::PathHandleGraph::operator=(const class handlegraph::PathHandleGraph &) --> class handlegraph::PathHandleGraph &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("assign", (class handlegraph::MutablePathDeletableHandleGraph & (handlegraph::MutablePathDeletableHandleGraph::*)(const class handlegraph::MutablePathDeletableHandleGraph &)) &handlegraph::MutablePathDeletableHandleGraph::operator=, "C++: handlegraph::MutablePathDeletableHandleGraph::operator=(const class handlegraph::MutablePathDeletableHandleGraph &) --> class handlegraph::MutablePathDeletableHandleGraph &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("get_magic_number", (unsigned int (bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)() const) &bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_magic_number, "C++: bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::get_magic_number() const --> unsigned int");
		cl.def("deserialize", (void (bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &)) &bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::deserialize, "C++: bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::deserialize(const std::string &) --> void", pybind11::arg("filename"));
		cl.def("serialize", (void (bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const std::string &)) &bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::serialize, "C++: bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::serialize(const std::string &) --> void", pybind11::arg("filename"));
		cl.def("assign", (struct bdsg::SerializableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::SerializableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::SerializableHandleGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::SerializableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::SerializableHandleGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("assign", (struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > & (bdsg::AbstractGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend>>::*)(const struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &)) &bdsg::AbstractGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=, "C++: bdsg::AbstractGraphProxy<bdsg::BasePackedGraph<bdsg::MappedBackend> >::operator=(const struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &) --> struct bdsg::AbstractGraphProxy<class bdsg::BasePackedGraph<struct bdsg::MappedBackend> > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
		cl.def("assign", (class handlegraph::SerializableHandleGraph & (handlegraph::SerializableHandleGraph::*)(const class handlegraph::SerializableHandleGraph &)) &handlegraph::SerializableHandleGraph::operator=, "C++: handlegraph::SerializableHandleGraph::operator=(const class handlegraph::SerializableHandleGraph &) --> class handlegraph::SerializableHandleGraph &", pybind11::return_value_policy::automatic, pybind11::arg(""));
	}
}
